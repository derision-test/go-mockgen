package generation

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/derision-test/go-mockgen/internal/mockgen/consts"
	"github.com/derision-test/go-mockgen/internal/mockgen/paths"
	"github.com/derision-test/go-mockgen/internal/mockgen/types"
)

type Options struct {
	ImportPaths       []string
	PkgName           string
	Interfaces        []string
	Exclude           []string
	OutputFilename    string
	OutputDir         string
	OutputImportPath  string
	Prefix            string
	Force             bool
	DisableFormatting bool
	GoImportsBinary   string
	ForTest           bool
}

func Generate(ifaces []*types.Interface, opts *Options) error {
	if opts.OutputFilename != "" {
		return generateFile(ifaces, opts)
	}

	return generateDirectory(ifaces, opts)
}

func generateFile(ifaces []*types.Interface, opts *Options) error {
	basename := opts.OutputFilename
	if opts.ForTest {
		ext := filepath.Ext(basename)
		basename = strings.TrimSuffix(basename, ext) + "_test" + ext
	}

	filename := filepath.Join(opts.OutputDir, basename)

	exists, err := paths.Exists(filename)
	if err != nil {
		return err
	}
	if exists && !opts.Force {
		return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(filename))
	}

	return generateAndRender(ifaces, filename, opts)
}

func generateDirectory(ifaces []*types.Interface, opts *Options) error {
	var prefix string
	if opts.Prefix != "" {
		prefix = opts.Prefix + "_"
	}

	suffix := "_mock"
	if opts.ForTest {
		suffix += "_test"
	}

	makeFilename := func(interfaceName string) string {
		filename := fmt.Sprintf("%s%s%s.go", prefix, interfaceName, suffix)
		return path.Join(opts.OutputDir, strings.Replace(strings.ToLower(filename), "-", "_", -1))
	}

	if !opts.Force {
		allPaths := make([]string, 0, len(ifaces))
		for _, iface := range ifaces {
			allPaths = append(allPaths, makeFilename(iface.Name))
		}

		conflict, err := paths.AnyExists(allPaths)
		if err != nil {
			return err
		}
		if conflict != "" {
			return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(conflict))
		}
	}

	for _, iface := range ifaces {
		if err := generateAndRender([]*types.Interface{iface}, makeFilename(iface.Name), opts); err != nil {
			return err
		}
	}

	return nil
}

func generateAndRender(ifaces []*types.Interface, filename string, opts *Options) error {
	pkgName := opts.PkgName
	if opts.ForTest {
		pkgName += "_test"
	}

	content, err := generateContent(ifaces, pkgName, opts.Prefix, opts.OutputImportPath)
	if err != nil {
		return err
	}

	log.Printf("writing to '%s'\n", paths.GetRelativePath(filename))
	if err := ioutil.WriteFile(filename, []byte(content), 0644); err != nil {
		return err
	}

	if !opts.DisableFormatting {
		if err := exec.Command(opts.GoImportsBinary, "-w", filename).Run(); err != nil {
			return errorWithSolutions{
				err: fmt.Errorf("failed to format file: %s", err),
				solutions: []string{
					"install goimports on your PATH",
					"specify a non-standard path to a goimports binary via --goimports",
					"disable post-render formatting via --disable-formatting",
				},
			}
		}
	}

	return nil
}

func generateContent(ifaces []*types.Interface, pkgName, prefix, outputImportPath string) (string, error) {
	file := jen.NewFile(pkgName)
	file.HeaderComment(fmt.Sprintf("Code generated by %s %s; DO NOT EDIT.", consts.Name, consts.Version))

	for _, iface := range ifaces {
		log.Printf("generating code for interface '%s'\n", iface.Name)
		generateInterface(file, iface, prefix, outputImportPath)
	}

	buffer := &bytes.Buffer{}
	if err := file.Render(buffer); err != nil {
		return "", err
	}

	return buffer.String(), nil
}

func generateInterface(file *jen.File, iface *types.Interface, prefix, outputImportPath string) {
	topLevelGenerators := []func(*wrappedInterface, string) jen.Code{
		generateMockStruct,
		generateMockStructConstructor,
		generateMockStructStrictConstructor,
		generateMockStructFromConstructor,
	}

	methodGenerators := []func(*wrappedInterface, *wrappedMethod, string) jen.Code{
		generateMockFuncStruct,
		generateMockInterfaceMethod,
		generateMockFuncSetHookMethod,
		generateMockFuncPushHookMethod,
		generateMockFuncSetReturnMethod,
		generateMockFuncPushReturnMethod,
		generateMockFuncNextHookMethod,
		generateMockFuncAppendCallMethod,
		generateMockFuncHistoryMethod,
		generateMockFuncCallStruct,
		generateMockFuncCallArgsMethod,
		generateMockFuncCallResultsMethod,
	}

	titleName := strings.ToUpper(string(iface.Name[0])) + iface.Name[1:]
	mockStructName := fmt.Sprintf("Mock%s%s", prefix, titleName)
	wrappedInterface := wrapInterface(iface, prefix, titleName, mockStructName, outputImportPath)

	for _, generator := range topLevelGenerators {
		file.Add(generator(wrappedInterface, outputImportPath))
		file.Line()
	}

	for _, method := range wrappedInterface.wrappedMethods {
		for _, generator := range methodGenerators {
			file.Add(generator(wrappedInterface, method, outputImportPath))
			file.Line()
		}
	}
}
