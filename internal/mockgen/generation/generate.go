package generation

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/derision-test/go-mockgen/internal/mockgen/consts"
	"github.com/derision-test/go-mockgen/internal/mockgen/paths"
	"github.com/derision-test/go-mockgen/internal/mockgen/types"
)

func Generate(ifaces []*types.Interface, opts *Options) error {
	if opts.OutputFilename == "" && opts.OutputDir != "" {
		return generateDirectory(ifaces, opts)
	}

	return generateFile(ifaces, opts)
}

func generateFile(ifaces []*types.Interface, opts *Options) error {
	content, err := generateContent(ifaces, opts.PkgName, opts.Prefix, opts.OutputImportPath)
	if err != nil {
		return err
	}

	if opts.OutputFilename != "" {
		exists, err := paths.Exists(opts.OutputFilename)
		if err != nil {
			return err
		}
		if exists && !opts.Force {
			return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(opts.OutputFilename))
		}

		log.Printf("writing to '%s'\n", paths.GetRelativePath(opts.OutputFilename))
		return ioutil.WriteFile(opts.OutputFilename, []byte(content), 0644)
	}

	fmt.Printf("%s\n", content)
	return nil
}

func generateDirectory(ifaces []*types.Interface, opts *Options) error {
	dirname := filepath.Join(opts.OutputDir, opts.OutputFilename)

	var prefix string
	if opts.Prefix != "" {
		prefix = opts.Prefix + "_"
	}

	makeFilename := func(interfaceName string) string {
		filename := fmt.Sprintf("%s%s_mock.go", prefix, interfaceName)
		return path.Join(dirname, strings.Replace(strings.ToLower(filename), "-", "_", -1))
	}

	if !opts.Force {
		allPaths := []string{}
		for _, iface := range ifaces {
			allPaths = append(allPaths, makeFilename(iface.Name))
		}

		conflict, err := paths.AnyExists(allPaths)
		if err != nil {
			return err
		}
		if conflict != "" {
			return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(conflict))
		}
	}

	for _, iface := range ifaces {
		content, err := generateContent([]*types.Interface{iface}, opts.PkgName, opts.Prefix, opts.OutputImportPath)
		if err != nil {
			return err
		}

		filename := makeFilename(iface.Name)
		log.Printf("writing to '%s'\n", paths.GetRelativePath(filename))
		if err := ioutil.WriteFile(filename, []byte(content), 0644); err != nil {
			return err
		}
	}

	return nil
}

func generateContent(ifaces []*types.Interface, pkgName, prefix, outputImportPath string) (string, error) {
	file := jen.NewFile(pkgName)
	file.HeaderComment(fmt.Sprintf("Code generated by %s %s; DO NOT EDIT.", consts.Name, consts.Version))

	for _, iface := range ifaces {
		log.Printf("generating code for interface '%s'\n", iface.Name)
		generateInterface(file, iface, prefix, outputImportPath)
	}

	buffer := &bytes.Buffer{}
	if err := file.Render(buffer); err != nil {
		return "", err
	}

	return buffer.String(), nil
}
