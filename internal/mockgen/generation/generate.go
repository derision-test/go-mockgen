package generation

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/derision-test/go-mockgen/internal/mockgen/consts"
	"github.com/derision-test/go-mockgen/internal/mockgen/paths"
	"github.com/derision-test/go-mockgen/internal/mockgen/types"
)

func Generate(ifaces []*types.Interface, opts *Options) error {
	if opts.OutputFilename != "" {
		return generateFile(ifaces, opts)
	}

	return generateDirectory(ifaces, opts)
}

func generateFile(ifaces []*types.Interface, opts *Options) error {
	filename := filepath.Join(opts.OutputDir, opts.OutputFilename)

	exists, err := paths.Exists(filename)
	if err != nil {
		return err
	}
	if exists && !opts.Force {
		return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(filename))
	}

	return generateAndRender(ifaces, filename, opts)
}

func generateDirectory(ifaces []*types.Interface, opts *Options) error {
	var prefix string
	if opts.Prefix != "" {
		prefix = opts.Prefix + "_"
	}

	makeFilename := func(interfaceName string) string {
		filename := fmt.Sprintf("%s%s_mock.go", prefix, interfaceName)
		return path.Join(opts.OutputDir, strings.Replace(strings.ToLower(filename), "-", "_", -1))
	}

	if !opts.Force {
		allPaths := []string{}
		for _, iface := range ifaces {
			allPaths = append(allPaths, makeFilename(iface.Name))
		}

		conflict, err := paths.AnyExists(allPaths)
		if err != nil {
			return err
		}
		if conflict != "" {
			return fmt.Errorf("filename %s already exists, overwrite with --force", paths.GetRelativePath(conflict))
		}
	}

	for _, iface := range ifaces {
		if err := generateAndRender([]*types.Interface{iface}, makeFilename(iface.Name), opts); err != nil {
			return err
		}
	}

	return nil
}

func generateAndRender(ifaces []*types.Interface, filename string, opts *Options) error {
	content, err := generateContent(ifaces, opts.PkgName, opts.Prefix, opts.OutputImportPath)
	if err != nil {
		return err
	}

	log.Printf("writing to '%s'\n", paths.GetRelativePath(filename))
	if err := ioutil.WriteFile(filename, []byte(content), 0644); err != nil {
		return err
	}

	if !opts.DisableFormatting {
		if err := exec.Command(opts.GoImportsBinary, "-w", filename).Run(); err != nil {
			return errorWithSolutions{
				err: fmt.Errorf("failed to format file: %s", err),
				solutions: []string{
					"install goimports on your PATH",
					"specify a non-standard path to a goimports binary via --goimports",
					"disable post-render formatting via --disable-formatting",
				},
			}
		}
	}

	return nil
}

func generateContent(ifaces []*types.Interface, pkgName, prefix, outputImportPath string) (string, error) {
	file := jen.NewFile(pkgName)
	file.HeaderComment(fmt.Sprintf("Code generated by %s %s; DO NOT EDIT.", consts.Name, consts.Version))

	for _, iface := range ifaces {
		log.Printf("generating code for interface '%s'\n", iface.Name)
		generateInterface(file, iface, prefix, outputImportPath)
	}

	buffer := &bytes.Buffer{}
	if err := file.Render(buffer); err != nil {
		return "", err
	}

	return buffer.String(), nil
}

type errorWithSolutions struct {
	err       error
	solutions []string
}

func (e errorWithSolutions) Error() string       { return e.err.Error() }
func (e errorWithSolutions) Solutions() []string { return e.solutions }
